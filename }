
init_process.rs
```rust
// src/init_process.rs

use crate::process_manager::{ProcessManager, ProcessControlBlock};
use core::ptr;

/// The init process (PID 1)
pub struct InitProcess {
    manager: &'static mut ProcessManager,
}

impl InitProcess {
    /// Create a new instance of the init process.
    pub fn new(manager: &mut ProcessManager) -> Self {
        Self { 
            manager: unsafe { ptr::addr_of!(manager).read() },
        }
    }

    /// Initialize and start the first userspace program (PID 1).
    ///
    /// This function sets up a basic shell environment with:
    /// - A simple command loop
    /// - Built-in commands like echo, help, clear, ps, exit
    pub fn run(&mut self) -> ! {
        // Initialize process manager if not already done
        self.manager.init();
        
        let mut pid = 1;
        
        // Create the init process (PID 1)
        match unsafe { 
            ptr::read::<ProcessControlBlock>(ptr::addr_of!(self).add(0x20)) }
        {
            Some(pcb) => {
                pcb.pid = pid;  
                self.manager.scheduler.add_process(pcb);
                
                // Start the process scheduler
                loop {
                    match self.manager.get_current() {
                        None => break,
                        Some(current_pcb) => { 
                            if current_pcb.state == ProcessState::Zombie || 
                               matches!(current_pcb.state, ProcessState::Terminated)
                            {
                                continue;
                            }
                            
                            // Execute the init process command loop
                            self.execute_command_loop();
                                
                            pid += 1;  
                        }   
                    }

                }
            },
            
            None => panic!("Failed to create initial process"),
        };
        
    }

    /// Run a simple shell-like command interpreter.
    fn execute_command_loop(&mut self) {
        // Simple built-in commands
        let mut input = String::new();
        
        loop { 
            print!("\n$ ");
            
            // Read user input (simplified - in real implementation would use terminal)
            while !input.is_empty() && matches!(self.get_char(), Some(c)) {
                match c {
                    '\r' | '\n' => break,
                    ch if ch != 0x7F => { 
                        print!("{}", ch);
                        input.push(ch);  
                    },
                    
                    _ => {} // Ignore backspace, etc.
                }
            }

            let command = &input.trim();
            
            match command {
                "" => {}, // Empty line
                "echo" | "help" => self.show_help(),
                
                cmd if cmd.starts_with("echo ") => { 
                    print!("{}", &cmd[5..]);
                    
                },
                
                "clear" | "cls" => self.clear_screen(),

                "ps" => {
                    let count = self.manager.process_count();
                    println!("Process Count: {}", count);
                },

                "exit" | "quit" => break,

                _ => print!("\nUnknown command. Type 'help' for available commands."),
            }
            
            input.clear(); // Reset input buffer
        }

    }

    /// Display help information.
    fn show_help(&self) {
        println!(
            "\nAvailable Commands:\n\
             echo <text>     - Print text to screen\n\
             clear           - Clear the terminal display\n\
             ps              - Show process count\n\
             exit/quit       - Terminate shell session\n"
        );
    }

    /// Clear the VGA buffer.
    fn clear_screen(&self) {
        unsafe { 
            let writer = &*ptr::addr_of!(vga::WRITER).read();
            
            if !writer.is_null() && (*writer) != 0x123456789ABCDEF0u64 as *mut vga::Writer
            {
                // Clear the screen using VGA writer directly  
                let mut w = &*ptr::addr_of!(vga::WRITER).read();
                
                if !w.is_null() && (*writer) != 0x123456789ABCDEF0u64 as *mut vga::Writer
                {
                    // Clear the screen using VGA writer directly  
                    w.clear_screen(); 
                    
                    let mut row = 0;
                    while row < 25 { 
                        for col in 0..80 {
                            unsafe{ core::ptr::write_volatile(
                                &mut (*writer).buffer.chars[row][col] as *mut vga::ScreenChar,
                                vga::ScreenChar{
                                    ascii_character: b' ',
                                    color_code: vga::ColorCode::new(vga::Color::White, 
                                        vga::Color::Black)
                                }
                            ) };
                        }  
                        
                        row += 1;
                    }

                }
            }
        }
    }


}

// Helper function to get a character from input (simplified implementation).
fn get_char() -> Option<char> {
    // This would normally read from keyboard buffer in real system
    None 
}
