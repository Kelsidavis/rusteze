
init_process.rs
```rust
// src/init_process.rs

use crate::process_manager::{ProcessManager, ProcessControlBlock};
use core::ptr;

/// Initialize the first userspace process (PID 1)
pub fn init_init_process() -> Result<(), &'static str> {
    // Create a new instance of our ELF loader and attempt to load
    let elf_ptr = unsafe { &__binary_start as *const u8 };
    
    match unsafe { crate::elf_loader::ElfLoader::new(elf_ptr) } {
        Some(mut loader) => {
            if !loader.is_loadable() {
                return Err("ELF file is not loadable");
            }
            
            // Load the ELF binary into physical memory
            let base_addr = PhysAddr::from_start_addr(
                unsafe { &__binary_end as *const _ } 
                    .addr()
                        + 0x1_0000, /* Add offset for userspace */
            ).unwrap_or_else(|_| panic!("Invalid address"));
            
            match loader.load(base_addr) {
                Ok(_) => println!("Successfully loaded init process from ELF binary"),
                Err(e) => return Err(e),
            }
        },
        
        None => { 
            // Fallback: Use embedded static binary
            let mut proc_manager = ProcessManager::new();
            let entry_point = unsafe { &__binary_start as *const _ } as u64;
            
            if !proc_manager.spawn_kernel_thread(|| {
                println!("Starting init process at address 0x{:X}", entry_point);
                
                // Simulate a simple "hello world" program
                for i in 1..=5 {
                    print!("[init] Hello from PID {} - Iteration {}\n", 
                        proc_manager.next_pid, i);  
                    
                    unsafe { core::hint::spin_loop(); }
                }

            }) {
                return Err("Failed to spawn init process");
            } else if let Some(current) = proc_manager.get_current() {
                println!("Init process PID: {}", current.pid);
                
                // Set up the initial state for our first userspace program
                unsafe { 
                    core::ptr::write_volatile(
                        &mut (*current.context).rip as *const u64,
                        entry_point, /* Entry point from ELF */
                    );
                    
                    core::ptr::write_volatile(
                        &mut (*current.context).rsp as *const u64,
                        0x7fff_ffff_ffff, // Stack pointer (example)
                    );

                }
            } else {
                return Err("Failed to get current process");
            }

        },
    };

    Ok(())
}

// Helper function for getting the binary start and end
extern "C" {
    fn __binary_start();
    fn __binary_end();
}
